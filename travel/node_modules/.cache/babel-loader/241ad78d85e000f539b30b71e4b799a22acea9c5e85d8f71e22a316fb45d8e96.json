{"ast":null,"code":"const VersionCheck = require('./version-check');\nconst Regex = require('./regex');\n\n/**\r\n * Numeric mode encodes data from the decimal digit set (0 - 9)\r\n * (byte values 30HEX to 39HEX).\r\n * Normally, 3 data characters are represented by 10 bits.\r\n *\r\n * @type {Object}\r\n */\nexports.NUMERIC = {\n  id: 'Numeric',\n  bit: 1 << 0,\n  ccBits: [10, 12, 14]\n};\n\n/**\r\n * Alphanumeric mode encodes data from a set of 45 characters,\r\n * i.e. 10 numeric digits (0 - 9),\r\n *      26 alphabetic characters (A - Z),\r\n *   and 9 symbols (SP, $, %, *, +, -, ., /, :).\r\n * Normally, two input characters are represented by 11 bits.\r\n *\r\n * @type {Object}\r\n */\nexports.ALPHANUMERIC = {\n  id: 'Alphanumeric',\n  bit: 1 << 1,\n  ccBits: [9, 11, 13]\n};\n\n/**\r\n * In byte mode, data is encoded at 8 bits per character.\r\n *\r\n * @type {Object}\r\n */\nexports.BYTE = {\n  id: 'Byte',\n  bit: 1 << 2,\n  ccBits: [8, 16, 16]\n};\n\n/**\r\n * The Kanji mode efficiently encodes Kanji characters in accordance with\r\n * the Shift JIS system based on JIS X 0208.\r\n * The Shift JIS values are shifted from the JIS X 0208 values.\r\n * JIS X 0208 gives details of the shift coded representation.\r\n * Each two-byte character value is compacted to a 13-bit binary codeword.\r\n *\r\n * @type {Object}\r\n */\nexports.KANJI = {\n  id: 'Kanji',\n  bit: 1 << 3,\n  ccBits: [8, 10, 12]\n};\n\n/**\r\n * Mixed mode will contain a sequences of data in a combination of any of\r\n * the modes described above\r\n *\r\n * @type {Object}\r\n */\nexports.MIXED = {\n  bit: -1\n};\n\n/**\r\n * Returns the number of bits needed to store the data length\r\n * according to QR Code specifications.\r\n *\r\n * @param  {Mode}   mode    Data mode\r\n * @param  {Number} version QR Code version\r\n * @return {Number}         Number of bits\r\n */\nexports.getCharCountIndicator = function getCharCountIndicator(mode, version) {\n  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode);\n  if (!VersionCheck.isValid(version)) {\n    throw new Error('Invalid version: ' + version);\n  }\n  if (version >= 1 && version < 10) return mode.ccBits[0];else if (version < 27) return mode.ccBits[1];\n  return mode.ccBits[2];\n};\n\n/**\r\n * Returns the most efficient mode to store the specified data\r\n *\r\n * @param  {String} dataStr Input data string\r\n * @return {Mode}           Best mode\r\n */\nexports.getBestModeForData = function getBestModeForData(dataStr) {\n  if (Regex.testNumeric(dataStr)) return exports.NUMERIC;else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;else if (Regex.testKanji(dataStr)) return exports.KANJI;else return exports.BYTE;\n};\n\n/**\r\n * Return mode name as string\r\n *\r\n * @param {Mode} mode Mode object\r\n * @returns {String}  Mode name\r\n */\nexports.toString = function toString(mode) {\n  if (mode && mode.id) return mode.id;\n  throw new Error('Invalid mode');\n};\n\n/**\r\n * Check if input param is a valid mode object\r\n *\r\n * @param   {Mode}    mode Mode object\r\n * @returns {Boolean} True if valid mode, false otherwise\r\n */\nexports.isValid = function isValid(mode) {\n  return mode && mode.bit && mode.ccBits;\n};\n\n/**\r\n * Get mode object from its name\r\n *\r\n * @param   {String} string Mode name\r\n * @returns {Mode}          Mode object\r\n */\nfunction fromString(string) {\n  if (typeof string !== 'string') {\n    throw new Error('Param is not a string');\n  }\n  const lcStr = string.toLowerCase();\n  switch (lcStr) {\n    case 'numeric':\n      return exports.NUMERIC;\n    case 'alphanumeric':\n      return exports.ALPHANUMERIC;\n    case 'kanji':\n      return exports.KANJI;\n    case 'byte':\n      return exports.BYTE;\n    default:\n      throw new Error('Unknown mode: ' + string);\n  }\n}\n\n/**\r\n * Returns mode from a value.\r\n * If value is not a valid mode, returns defaultValue\r\n *\r\n * @param  {Mode|String} value        Encoding mode\r\n * @param  {Mode}        defaultValue Fallback value\r\n * @return {Mode}                     Encoding mode\r\n */\nexports.from = function from(value, defaultValue) {\n  if (exports.isValid(value)) {\n    return value;\n  }\n  try {\n    return fromString(value);\n  } catch (e) {\n    return defaultValue;\n  }\n};","map":{"version":3,"names":["VersionCheck","require","Regex","exports","NUMERIC","id","bit","ccBits","ALPHANUMERIC","BYTE","KANJI","MIXED","getCharCountIndicator","mode","version","Error","isValid","getBestModeForData","dataStr","testNumeric","testAlphanumeric","testKanji","toString","fromString","string","lcStr","toLowerCase","from","value","defaultValue","e"],"sources":["C:/Users/zcy/Desktop/code/gztravel/travel/node_modules/qrcode/lib/core/mode.js"],"sourcesContent":["const VersionCheck = require('./version-check')\r\nconst Regex = require('./regex')\r\n\r\n/**\r\n * Numeric mode encodes data from the decimal digit set (0 - 9)\r\n * (byte values 30HEX to 39HEX).\r\n * Normally, 3 data characters are represented by 10 bits.\r\n *\r\n * @type {Object}\r\n */\r\nexports.NUMERIC = {\r\n  id: 'Numeric',\r\n  bit: 1 << 0,\r\n  ccBits: [10, 12, 14]\r\n}\r\n\r\n/**\r\n * Alphanumeric mode encodes data from a set of 45 characters,\r\n * i.e. 10 numeric digits (0 - 9),\r\n *      26 alphabetic characters (A - Z),\r\n *   and 9 symbols (SP, $, %, *, +, -, ., /, :).\r\n * Normally, two input characters are represented by 11 bits.\r\n *\r\n * @type {Object}\r\n */\r\nexports.ALPHANUMERIC = {\r\n  id: 'Alphanumeric',\r\n  bit: 1 << 1,\r\n  ccBits: [9, 11, 13]\r\n}\r\n\r\n/**\r\n * In byte mode, data is encoded at 8 bits per character.\r\n *\r\n * @type {Object}\r\n */\r\nexports.BYTE = {\r\n  id: 'Byte',\r\n  bit: 1 << 2,\r\n  ccBits: [8, 16, 16]\r\n}\r\n\r\n/**\r\n * The Kanji mode efficiently encodes Kanji characters in accordance with\r\n * the Shift JIS system based on JIS X 0208.\r\n * The Shift JIS values are shifted from the JIS X 0208 values.\r\n * JIS X 0208 gives details of the shift coded representation.\r\n * Each two-byte character value is compacted to a 13-bit binary codeword.\r\n *\r\n * @type {Object}\r\n */\r\nexports.KANJI = {\r\n  id: 'Kanji',\r\n  bit: 1 << 3,\r\n  ccBits: [8, 10, 12]\r\n}\r\n\r\n/**\r\n * Mixed mode will contain a sequences of data in a combination of any of\r\n * the modes described above\r\n *\r\n * @type {Object}\r\n */\r\nexports.MIXED = {\r\n  bit: -1\r\n}\r\n\r\n/**\r\n * Returns the number of bits needed to store the data length\r\n * according to QR Code specifications.\r\n *\r\n * @param  {Mode}   mode    Data mode\r\n * @param  {Number} version QR Code version\r\n * @return {Number}         Number of bits\r\n */\r\nexports.getCharCountIndicator = function getCharCountIndicator (mode, version) {\r\n  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode)\r\n\r\n  if (!VersionCheck.isValid(version)) {\r\n    throw new Error('Invalid version: ' + version)\r\n  }\r\n\r\n  if (version >= 1 && version < 10) return mode.ccBits[0]\r\n  else if (version < 27) return mode.ccBits[1]\r\n  return mode.ccBits[2]\r\n}\r\n\r\n/**\r\n * Returns the most efficient mode to store the specified data\r\n *\r\n * @param  {String} dataStr Input data string\r\n * @return {Mode}           Best mode\r\n */\r\nexports.getBestModeForData = function getBestModeForData (dataStr) {\r\n  if (Regex.testNumeric(dataStr)) return exports.NUMERIC\r\n  else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC\r\n  else if (Regex.testKanji(dataStr)) return exports.KANJI\r\n  else return exports.BYTE\r\n}\r\n\r\n/**\r\n * Return mode name as string\r\n *\r\n * @param {Mode} mode Mode object\r\n * @returns {String}  Mode name\r\n */\r\nexports.toString = function toString (mode) {\r\n  if (mode && mode.id) return mode.id\r\n  throw new Error('Invalid mode')\r\n}\r\n\r\n/**\r\n * Check if input param is a valid mode object\r\n *\r\n * @param   {Mode}    mode Mode object\r\n * @returns {Boolean} True if valid mode, false otherwise\r\n */\r\nexports.isValid = function isValid (mode) {\r\n  return mode && mode.bit && mode.ccBits\r\n}\r\n\r\n/**\r\n * Get mode object from its name\r\n *\r\n * @param   {String} string Mode name\r\n * @returns {Mode}          Mode object\r\n */\r\nfunction fromString (string) {\r\n  if (typeof string !== 'string') {\r\n    throw new Error('Param is not a string')\r\n  }\r\n\r\n  const lcStr = string.toLowerCase()\r\n\r\n  switch (lcStr) {\r\n    case 'numeric':\r\n      return exports.NUMERIC\r\n    case 'alphanumeric':\r\n      return exports.ALPHANUMERIC\r\n    case 'kanji':\r\n      return exports.KANJI\r\n    case 'byte':\r\n      return exports.BYTE\r\n    default:\r\n      throw new Error('Unknown mode: ' + string)\r\n  }\r\n}\r\n\r\n/**\r\n * Returns mode from a value.\r\n * If value is not a valid mode, returns defaultValue\r\n *\r\n * @param  {Mode|String} value        Encoding mode\r\n * @param  {Mode}        defaultValue Fallback value\r\n * @return {Mode}                     Encoding mode\r\n */\r\nexports.from = function from (value, defaultValue) {\r\n  if (exports.isValid(value)) {\r\n    return value\r\n  }\r\n\r\n  try {\r\n    return fromString(value)\r\n  } catch (e) {\r\n    return defaultValue\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}